<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://song-gan.github.io</id>
    <title>Crystal_gan</title>
    <updated>2022-04-18T05:49:48.552Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://song-gan.github.io"/>
    <link rel="self" href="https://song-gan.github.io/atom.xml"/>
    <subtitle>恭喜你！发现了Crystal_gan的后花园</subtitle>
    <logo>https://song-gan.github.io/images/avatar.png</logo>
    <icon>https://song-gan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Crystal_gan</rights>
    <entry>
        <title type="html"><![CDATA[【中考游记】体育中考]]></title>
        <id>https://song-gan.github.io/post/zhong-kao-you-ji-ti-yu-zhong-kao/</id>
        <link href="https://song-gan.github.io/post/zhong-kao-you-ji-ti-yu-zhong-kao/">
        </link>
        <updated>2022-04-13T05:22:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="font-size5-colorred記font体育中考满分"><font size="5" color="red">『記』</font>体育中考满分</h2>
<h3 id="2022年4月12日"><strong>2022年4月12日</strong></h3>
<ul>
<li>首先聊一聊为准备体考的那些儿事：</li>
</ul>
<ol>
<li>
<p>亲爱的DC为了在短期内提升考生们的成绩，加大了每天大课间的锻炼量，三圈的400米，无尽的蛙跳与俯卧撑~~ 一个月内成功让我先后扭伤了腰，崴到了脚， 拉伤了筋，前前后后 <em><s>划水</s></em> 疗伤了一两周后，突然就可以跳到2米5了！</p>
</li>
<li>
<p>在距离体育中考还有1天的时候，为了验证我的伤是不是好的差不多，于是中午借上厕所之余，在教学楼的走廊里练习了一下立定跳远，不成想，一跳就滑倒了，尾椎骨的惨叫~ 新伤+1</p>
</li>
<li>
<p>下午第二节课是高中数学课，本来可以上完一整节课，这是赵老师过来跟吴老师耳语了一番，于是让我们上自习， 20 分钟后拿出了语文字词单子订正答案。</p>
</li>
<li>
<p>班上准备了红牛和巧克力，大家都在出发前把红牛喝了。结果下去就有挪威行为：“在喝红牛的那个瓜娃子放下！这东西你懂不懂你就在乱喝！这东西是你跑完中长跑累的着不住的时候喝补充体力的！“还好我的包里面还剩下了昨天买的一条士力架，虽然融化了，但是还是在1000米后拯救了我！</p>
</li>
</ol>
<ul>
<li>
<p>开始前，老师讲解了一些注意事项。</p>
</li>
<li>
<p>不幸带伤参考，下午体考的时候还是大太阳，29℃，还好是超常发挥，这中考体育80分拿满了，最没想到的是，我跳远今天轻轻一跳，还以为跳不到满分2米5了，结果2米57，全力的话2米7都应该没问题，跑1000米的时候我以为我会卡线冲过终点，结果直接全程领跑，小组里面第一名，真的没想到，3分20秒（满分：3分48秒）！</p>
</li>
<li>
<p>开始前，老师讲解了一些注意事项。<br>
不犯规，不吃亏。多观察，动脑筋。<br>
不犯规， | <font size="3" color="white"> 考试的时候如果发现任何可以提分的技巧，请悄悄告诉你的同学。</font><br>
不吃亏。 | <font size="3" color="white"> 比如说立定跳远可以跳出红外线检测区域，中长跑可以抄近道、抢跑……总之机器感应不到你的方法，记住，没有任何老师教你这些方法。</font><br>
多观察， | <font size="3" color="white"> 我们不提倡，不建议，不反对，也不负责。</font><br>
动脑筋。 | <font size="3" color="white"> 在考乒乓球的时候，监考老师会在你的手上写一个数字，如果这个数字小于 20 ，请先不要录入成绩，马上到篷子后面去找两个抽烟的老师。</font><br>
唐松 <font color="white"> &amp; 罗巍</font></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI学习笔记】IDA*算法]]></title>
        <id>https://song-gan.github.io/post/oi-xue-xi-bi-ji-idasuan-fa/</id>
        <link href="https://song-gan.github.io/post/oi-xue-xi-bi-ji-idasuan-fa/">
        </link>
        <updated>2022-03-05T05:44:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ida算法">IDA*算法</h2>
<ul>
<li>
<p>IDA<em>是对迭代加深搜索IDDFS的优化，我们可以把IDA</em>看作A*算法思想在迭代加深搜索中的应用。</p>
</li>
<li>
<p>IDDFS仍然是一种“盲目”的搜索方法，只是把搜索范围约束到了可行的空间内。如果在进行IDDFS的时候能预测当前DFS的状态，不在继续深入下去，那么我们就可以节约很大部分的时间，不在搜索这个分支，从而提高程序效率。</p>
</li>
<li>
<p>同之前的A*的算法，这个预测就是在IDDFS中增加一个估价函数。在某个状态，经过函数计算，发现后续搜索无解，就返回。简单地说，就是在IDDFS的过程中利用估价函数进行剪枝操作，我们看一道例题：</p>
</li>
</ul>
<h2 id="例题破坏正方形"><a href="https://www.acwing.com/problem/content/184/">【例题】破坏正方形</a></h2>
<h3 id="题解">题解</h3>
<ul>
<li>
<p>首先要处理出每个正方形的所有边编号</p>
</li>
<li>
<p>这也就是这题的难点，考虑如何描述一个正方形</p>
</li>
<li>
<p>我们可以用三个值描述一个正方形：</p>
</li>
<li>
<p>正方形边长和左上角横、纵坐标</p>
</li>
<li>
<p>那么我们接下来要做的就是对于每组 正方形边长和左上角横、纵坐标，找出它所有边的编号。</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://www.imageoss.com/images/2022/03/05/5.1.8-1-1e9cd42086a942f81.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://www.imageoss.com/images/2022/03/05/5.1.8-1-28c7e93276cf945a0.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>对于所有横着的火柴，我们将其坐标定义为其左端点坐标</p>
</li>
<li>
<p>对于所有竖着的火柴，我们将其坐标定义为其上端点坐标</p>
</li>
<li>
<p>举个例子，编号为15和18的火柴的坐标都是(2,0)</p>
</li>
<li>
<p>先考虑横着的火柴。对于坐标为(r,c)的火柴，其编号即为 坐标为 (r, 0) 的火柴的编号+c。而所有坐标为(r,0)的火柴的编号，正好构成一个 首项为1，公差为2n+1 的等差数列，其中 n 为网格边长。那么坐标为(r,0)的火柴，编号为1+r(2n+1)。所以坐标为(r,c)的火柴，编号为1+r(2n+1)+c。</p>
</li>
<li>
<p>再考虑竖着的火柴。对于所有坐标为(r,c)的火柴，其编号为 与其坐标相同的横着的火柴的编号+n所以坐标为(r,c)的火柴，编号为1+r(2n+1)+c+n</p>
</li>
<li>
<p>然后考虑每个正方形所包含的所有火柴的横纵坐标。对于一个左上角坐标为(r,c)，边长为len的正方形，不难发现其四个顶点的坐标分别为(r,c)，(r+len,c)，(r,c+len)，(r+len,c+len)。</p>
</li>
<li>
<p>考虑横着的火柴（以下i都从0开始），对于上边从左往右第 i个火柴，其坐标为(r,c+i)，所以其编号为 1+r(2n+1)+c+i。对于下边从左往右第 i个火柴，其坐标为(r+len,c+i)，所以其编号为 1+(r+len)(2n+1)+c+i。考虑竖着的火柴，对于左边从上往下第 i个火柴，其坐标为(r+i,c)，所以其编号为 1+(r+i)(2n+1)+c+n。对于右边从上往下第i个火柴，其坐标为(r+i,c+len)，所以其编号为 1+(r+i)(2n+1)+c+len+n。所以我们只需要从0到 len 枚举i，然后加边即可。</p>
</li>
<li>
<p>然后问题变成最少选出多少边，使得每个正方形中至少被选出一条边。</p>
</li>
<li>
<p>这是一个经典的重复覆盖问题，可以用 Dancing Links 求解。</p>
</li>
<li>
<p>这里我们不适用DLX这个数据结构，直接求解。</p>
</li>
</ul>
<h4 id="估计函数">估计函数：</h4>
<pre><code>枚举所有未被删掉的正方形，将其所有边全部删掉，只记删除一条边。这样估计出的值一定不大于真实值，满足IDA*对估价函数的要求。其实这也是Dancing Links求解重复覆盖问题时的估价函数。
</code></pre>
<h4 id="搜索顺序优化">搜索顺序优化：</h4>
<pre><code>找出最小的未被删除的正方形，依次枚举删除每条边。
</code></pre>
<h4 id="时间复杂度">时间复杂度</h4>
<pre><code>搜索空间是指数级别的，但由于启发函数和剪枝的存在，实际搜索到的状态较少。
</code></pre>
<pre><code class="language-cpp">//DC Songxingan
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

const int N = 61; // 网格最大是 5 * 5 的，其中最多会有 5 * (5 + 1) * 2 = 60 个正方形，所以要开到 61

int n, idx;            // n 为网格规模，idx 为正方形数量
int max_depth;         // IDA* 的 max_depth
vector&lt;int&gt; square[N]; // 存每个正方形边上的火柴的编号
bool used[N];          // 存每个火柴是否已经被破坏

// 新加一个左上角坐标为 (r, c)，边长为 len 的正方形
void add(int r, int c, int len)
{
    int d = n &lt;&lt; 1 | 1;
 	// 由于用到的 2n + 1 比较多，这里先用一个变量代替掉 2n + 1
    vector&lt;int&gt; &amp;s = square[idx];
    s.clear(); // 有多组测试数据，需要上一组数据的内容清空
    for (int i = 0; i &lt; len; i++)
    {
        s.push_back(1 + r * d + c + i);               // 上边第 i 个
        s.push_back(1 + (r + len) * d + c + i);       // 下边第 i 个
        s.push_back(1 + n + r * d + c + i * d);       // 左边第 i 个
        s.push_back(1 + n + r * d + c + i * d + len); // 右边第 i 个
    }
    idx++;
}

// 判断正方形 s 是否完整
bool check(vector&lt;int&gt; &amp;s)
{
    for (int i = 0; i &lt; s.size(); i++)
        if (used[s[i]])
            return false; // 如果其中有一条边已经被破坏了，那么说明不完整
    return true;          // 如果每条边都没被破坏，说明完整
}

// 估价函数
int f()
{
    static bool backup[N];             
// 由于要改动 used，需要先新建一个备份数组
    memcpy(backup, used, sizeof used); // 将 used 复制到备份数组中
    int res = 0;
    for (int i = 0; i &lt; idx; i++) // 枚举所有正方形
        if (check(square[i]))     // 如果某个正方形是完整的，
        {
            res++; // 那么 res ++ ，并将该正方形所有的边都删去
            for (int j = 0; j &lt; square[i].size(); j++)
                used[square[i][j]] = true;
        }
    memcpy(used, backup, sizeof used); // 复制回来
    return res;
}

// IDA*
bool dfs(int depth)
{
    if (depth + f() &gt; max_depth)
        return false;
    for (int i = 0; i &lt; idx; i++) // 枚举所有的正方形
        if (check(square[i]))     // 如果第 i 个正方形还没被破坏
        {
            // 那么枚举该正方形的所有边编号，去掉该边并继续爆搜
            for (int j = 0; j &lt; square[i].size(); j++)
            {
                used[square[i][j]] = true;
                if (dfs(depth + 1))
                    return true;
                used[square[i][j]] = false;
            }
            // 如果每条边都爆搜不成功，那么说明删掉 max_depth 个火柴无法破坏该正方形
            return false;
        }
    return true; // 如果所有的正方形都被破坏了，返回 true
}

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    {
        scanf(&quot;%d&quot;, &amp;n), idx = 0;          // 初始化 idx
        memset(used, false, sizeof used);  // 初始化 used
        for (int len = 1; len &lt;= n; len++) 
// 枚举 len, r, c，预处理每个正方形
            for (int r = 0; r + len &lt;= n; r++)
                for (int c = 0; c + len &lt;= n; c++)
                    add(r, c, len);
        int k;
        scanf(&quot;%d&quot;, &amp;k);
        while (k--) // 读入所有已经被破坏的边
        {
            int x;
            scanf(&quot;%d&quot;, &amp;x);
            used[x] = true;
        }
        max_depth = 0; // IDA*
        while (!dfs(0))
            max_depth++;
        printf(&quot;%d\n&quot;, max_depth);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI学习笔记】迭代加深搜索]]></title>
        <id>https://song-gan.github.io/post/oi-xue-xi-bi-ji-die-dai-jia-shen-sou-suo/</id>
        <link href="https://song-gan.github.io/post/oi-xue-xi-bi-ji-die-dai-jia-shen-sou-suo/">
        </link>
        <updated>2022-03-05T05:33:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="迭代加深搜索">迭代加深搜索</h2>
<ul>
<li>
<p>在我们切了很多搜索题后，相信大家会发现有些问题，它们的搜索树很特别，不仅很深并且很宽。此时，如果我们采用一般的DFS会陷入递归而无法返回，如果我们采用一般的BFS，队列可能会炸掉。对于这些问题，它的答案可能在某个较浅的节点上，但如果一开始就选错了分支，那么就很可能在不包含答案的深层子树上浪费许多时间。</p>
</li>
<li>
<p>迭代加深搜索通俗讲可以理解为“DFS + BFS”，具体操作方法如下：</p>
</li>
</ul>
<ol>
<li>
<p>我们先设定搜索深度为1，用DFS搜索到第1层即停止。也就是说，用DFS搜索一个深度为1 的搜索树。</p>
</li>
<li>
<p>如果没有找到答案，再将搜索深度增加2，用DFS搜索前2层即停止。也就是说，用DFS搜索一个深度为2的搜索树。</p>
</li>
<li>
<p>同理，我们每次增加搜索的深度，直到搜索到答案。</p>
</li>
</ol>
<ul>
<li>
<p>这整个迭代的过程，再每一层的广度上采用的是BFS的思想，但是在实现搜索的过程中采用的是DFS，只是控制了DFS搜索根节点的每个子树的深度。</p>
</li>
<li>
<p>那么就会有同学想说，假设搜索限制为d，每次需要重复跑1~d-1层上的节点，不是更耗费时间吗？但是我们知道当搜索树的节点分支很多时，层上的节点会以指数级增长，那么对于我们重复搜索的点就不值一提了。并且在搜索过程中我们采用记忆化搜索也可以很有效 地避免这个问题。</p>
</li>
<li>
<p>总而言之，当搜索树规模随着层次的深入增长很快，并且我们能够确保答案在一个较浅 的节点时，就可以采用迭代加深的深度优先搜素算法解决问题。</p>
</li>
</ul>
<h2 id="例题巴士"><a href="https://www.acwing.com/problem/content/188/">【例题】巴士</a></h2>
<h3 id="题解">题解</h3>
<pre><code class="language-cpp">//DC Songxingan
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#define PII pair&lt;int, int&gt;
using namespace std;
const int N = 2000, M = 60;
int n, bus[M];
vector&lt;pair&lt;int, PII&gt;&gt; routes;

bool is_route(int a, int d)
{
    for (int i = a; i &lt; 60; i += d)
        if (!bus[i])
            return false;
    return true;
}

bool DFS(int depth, int u, int sum, int start)
{
    if (u == depth)
        return sum == n;
    if (routes[start].first * (depth - u) + sum &lt; n)
        return false;
    for (int i = start; i &lt; routes.size(); i++)
    {
        auto r = routes[i];
        int a = r.second.first, d = r.second.second;
        if (!is_route(a, d))
            continue;
        for (int j = a; j &lt; 60; j += d)
            bus[j]--;
        if (DFS(depth, u + 1, sum + r.first, i))
            return true;
        for (int j = a; j &lt; 60; j += d)
            bus[j]++;
    }
    return false;
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i++)
    {
        int t;
        scanf(&quot;%d&quot;, &amp;t);
        bus[t]++;
    }

    for (int i = 0; i &lt; 60; i++)
        for (int j = i + 1; i + j &lt; 60; j++)
            if (is_route(i, j))
                routes.push_back({(59 - i) / j + 1, {i, j}});

    sort(routes.begin(), routes.end(), greater&lt;pair&lt;int, PII&gt;&gt;());

    int depth = 0;
    while (!DFS(depth, 0, 0, 0))
        depth++;

    printf(&quot;%d\n&quot;, depth);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI学习笔记】A*算法]]></title>
        <id>https://song-gan.github.io/post/oi-xue-xi-bi-ji-asuan-fa/</id>
        <link href="https://song-gan.github.io/post/oi-xue-xi-bi-ji-asuan-fa/">
        </link>
        <updated>2022-03-03T05:05:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="a算法">A*算法</h2>
<ul>
<li>
<p>我们知道BFS是一种“盲目”的搜索技术，它在搜索过程中并不会理会目标在哪里，只顾自己走，当然最后总会到达终点，但是时间空间复杂度就很难说了。</p>
</li>
<li>
<p>比如说举个例子：你要从家到学校，现在有很多的路可以选择，对于聪明的你来说当然可以准确地选择最短的路，因为你毕竟不是个瞎子，能看见路途中你距离学校的距离，能够判断思考，可以随时调整新的路径。但是，对程序来说它很呆板，对于一般的BFS它会扩展各个方向尝试去搜索，哪怕是与目标背道而行，越走越远，所以我们为了让程序不去做这些不必要的搜索，可以考虑将我们的“智慧”交给程序，知道应该朝目标方向去搜索，那么这就是“启发式搜索”。这一节我们将学习其中比较简单的一种A*算法。</p>
</li>
<li>
<p>通俗说，A*算法其实就是“BFS + 贪心”。</p>
</li>
<li>
<p>在具体探讨A*算法前，我们先回顾一下上一节的优先队列BFS算法。该算法维护了一个优先队列(二叉堆)，不断从堆中取出“当前代价最小”的状态(堆顶)进行扩展。每个状态被第一次从优先队中取出时，就得了从初始状态到该状态的最小代价。</p>
</li>
<li>
<p>那么如果给定一个“目标状态”，需要求出从初始到目标状态的最小代价，那么优先队列BFS的这个“优先策略”是有局限性的。一个状态的当前代价最小，我们只能说从初始状态到该状态的代价最小，但在未来的搜索中我们不能保证这就是最优的，可能从该状态到目标状态会花费很大的代价。相反，一些状态在当前代价略大，但它能成为全局的最优解。优先队列BFS最终是可以求出全局的最优解，因为它的一个状态的最优解是在不断更新的。但是在搜索中它会优先选择前者的分支，这就会导致求出最优解的搜索量增大，在时间与空间的复杂度上增大许多。其实A*算法与这有点类似于“动态规划”与“贪心”的区别。</p>
</li>
<li>
<p>再回到刚刚的例子，我们可以将从家到学校的路看最网格状的图，此时我们要曼哈顿距离的概念：曼哈顿距离——两点在横纵方向差的和，即d（i，j）=|xi-xj|+|yi-yj|。对于一个具备正南正北、正东正西方向规则布局的城镇街道，从一点到达另外一点的距离正是在南北方向上旅行的距离加上在东西方向上旅行的距离，所以，曼哈顿距离又称为出租车距离。</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://www.imageoss.com/images/2022/03/03/1992968c31aa9a86b.png" alt="曼哈顿距离" loading="lazy"></figure>
<ul>
<li>
<p>为了我们搜索的效率，我们很自然可以想到，可以对未来可能产生的代价进行评估。那么我们就需要设计一个“估价函数”，它的功能主要是评估从当前任意状态到目标状态所需代价的估计值。在搜索中，仍要我们去维护一个堆，不断从堆中取出“当前代价+未来估价”最小的状态进行接下来的扩展搜索。为了摆正第一次从堆中取出目标状态是得到的就是最优解，我们设计的估价函数必须要满足一个基本准则：</p>
</li>
<li>
<p>设是当前所在的状态，是对的评估函数；</p>
</li>
<li>
<p>那么满足：</p>
</li>
<li>
<p>表示从初始状态到达当前状态的实际代价，它不体现当前状态与目标的关系；</p>
</li>
<li>
<p>表示从当前状态到目标的最优路径的评估，它实际就是“启发式”信息，我们把成为启发函数，很显然决定了A*算法的优劣。</p>
</li>
<li>
<p>特别注意:不能漏掉最优解。</p>
</li>
<li>
<p>在之前从学校到家的例子中，我们需要用到的启发函数就是曼哈顿距离，这里为什么用曼哈顿距离作为启发函数请同学们自己思考。</p>
</li>
<li>
<p>回头再看，我们说到A*算法通俗的说其实就是“BFS + 贪心”：</p>
</li>
</ul>
<ol>
<li>
<p>如果，有，这其实就是不同的BFS算法，会访问大量方块。</p>
</li>
<li>
<p>如果，有，这其实就是贪心算法，这就会导致在扩展时，只注重与局部的最优解，达不到全局的最优解。更有可能陷入一个状态就出不来了。</p>
</li>
</ol>
<ul>
<li>综上，A*算法提高搜索效率的关键，就在于能否设计出一个优秀的估价函数。在满足基本准则的前提下，还应该尽可能反映未来实际代价的变化趋势和相对大小关系，这样搜索才会较快地逼近最优解。</li>
</ul>
<h2 id="例题第k短路"><a href="https://www.acwing.com/problem/content/180/">【例题】第k短路</a></h2>
<h3 id="题解">题解</h3>
<pre><code class="language-cpp">//DC Songxingan
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#define PII pair&lt;int, int&gt;
#define PIII pair&lt;int, PII&gt;
#define x first
#define y second
using namespace std;

const int N = 1010, M = 2e5 + 10;
int n, m, S, T, K;
int h[N], rh[N], e[M], w[M], ne[M], idx;
int dist[N];
bool st[N]; // 每个点用没用过

void add(int h[], int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}
// 在反向图上dijkstra()，保存估价函数(dist[]距离)
// dist存的是该点到终点的最小距离

void dijkstra()
{
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 优先队列，小根堆
    heap.push({0, T});                                   //终点T是这里的起点 &lt;距离，点编号&gt;
    memset(dist, 0x3f, sizeof dist);
    dist[T] = 0;
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
        int ver = t.y;
        if (st[ver])
            continue;
        st[ver] = true; // 遍历过
        // 在反向图上遍历，rh[]数组
        for (int i = rh[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] &gt; dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }
    }
}

int astar()
{
    //
    priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt;&gt; heap;
    // A* 算法，从起点开始搜
    heap.push({dist[S], {0, S}}); // 估价值，{真实值，编号}
    int cnt = 0;                  // 终点遍历几次
    // 无解的话，返回-1

    if (dist[S] == 0x3f3f3f3f)
        return -1;

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
        int ver = t.y.y, distance = t.y.x; //从起点到该点的真实距离
        if (ver == T)
            cnt++; // 遍历一遍终点， cnt++，直到第K次
        // 这个点是终点，并且是第k短路，直接返回第k短路的真实距离distance
        if (cnt == K)
            return distance;

        // 正向扩展所有的边
        // 用 起点到该点的真实距离+ 该点到终点的估价距离来作为标准
        // distance + w[i] + dist[j]
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            heap.push({distance + w[i] + dist[j], {distance + w[i], j}});
        }
    }

    return -1;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    // 初始化表头
    memset(h, -1, sizeof h);
    memset(rh, -1, sizeof rh);
    for (int i = 1; i &lt;= m; i++)
    {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        add(h, a, b, c);  // 建正边
        add(rh, b, a, c); // 建反边
    }
    scanf(&quot;%d%d%d&quot;, &amp;S, &amp;T, &amp;K);
    if (S == T)
        K++;

    dijkstra();
    printf(&quot;%d\n&quot;, astar());
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI学习笔记】双向BFS]]></title>
        <id>https://song-gan.github.io/post/oi-xue-xi-bi-ji-shuang-xiang-bfs/</id>
        <link href="https://song-gan.github.io/post/oi-xue-xi-bi-ji-shuang-xiang-bfs/">
        </link>
        <updated>2022-03-02T05:50:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="双向bfs">双向BFS</h2>
<ul>
<li>
<p>双向BFS我们可以看作是一般BFS的增强版。</p>
</li>
<li>
<p>我们可以把BFS想象成在一个平静的池塘中丢一颗石头，激起的波浪一层层扩散到整个空间，知道到达边界或目标状态，类比搜索就是得到了从起点到目标点的最优解。那么，我们可不可以考虑丢两块石头下去呢，一个在起点，一个在终点，同时向对方扩散，那么两个的波一定会在某个位置相交，此时就是最优解。</p>
</li>
<li>
<p>同理，我们进行BFS可以从起点和终点同时开始，相遇即最优解。双向BFS与一般BFS相比空间上会是少很多，从而更有效率。</p>
</li>
</ul>
<h3 id="我们有两种搜索方法">我们有两种搜索方法：</h3>
<ol>
<li>两个方向交替扩展。</li>
<li>选择节点个数较少的那个方向先扩展。</li>
</ol>
<ul>
<li>
<p>相比较两种方法，方法2 为只需要略加修改控制结构，每次while循环时只扩展正反两个方向中结点数目较少的那一个，可以时两边的发展速度保持一定的平衡，从而减少总扩展结点的个数，加快搜索速度。</p>
</li>
<li>
<p>所以，很明显 方法2 要优于 方法1。</p>
</li>
</ul>
<h2 id="例题噩梦"><a href="https://www.acwing.com/problem/content/179/">【例题】噩梦</a></h2>
<h3 id="题解">题解</h3>
<ul>
<li>
<p>由于是男孩和女孩同时移动，而不是只有一个人移动，所以这题要用双向广搜。</p>
</li>
<li>
<p>我们在bfs中按时间t从 1开始枚举。</p>
</li>
<li>
<p>如果男孩和女孩都不能再继续扩展，则跳出枚举。</p>
</li>
<li>
<p>对于男孩，每次扩展三步，并标记扩展到的格子。</p>
</li>
<li>
<p>如果某个能扩展的格子被女孩扩展过，那么直接返回现在的时间。</p>
</li>
<li>
<p>对于女孩，每次扩展一步，并标记扩展到的格子。</p>
</li>
<li>
<p>如果某个能扩展的格子被男孩扩展过，那么直接返回现在的时间。</p>
</li>
<li>
<p>对于鬼，由于鬼是无视墙的，所以我们只需要在扩展男孩和女孩的时候，判断下有没有进入鬼的占领范围即可。</p>
</li>
<li>
<p>题目中已经给出了，在第k秒后所有与鬼的曼哈顿距离不超过2k的位置都会被鬼占领。</p>
</li>
<li>
<p>我们在第t秒扩展的时候，判断被扩展的格子是否与某个鬼的曼哈顿距离小于2t即可。</p>
</li>
<li>
<p>详见代码及注释</p>
</li>
<li>
<p>时间复杂度</p>
</li>
<li>
<p>每个格子最多只会被扩展一次（如果被扩展了两次，男孩和女孩就会合惹~）</p>
</li>
<li>
<p>一共有T组测试数据，每组测试数据的地图有 N×M 个格子，</p>
</li>
<li>
<p>所以时间复杂度是 O(TNM)</p>
</li>
</ul>
<pre><code class="language-cpp">//DC Songxingan
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#define pii pair&lt;int, int&gt;
using namespace std;
int n, m;
int T;
char a[810][810];
int reach[810][810]; //统计可达性，男孩为1，女孩为2
pii girl, boy, z[3]; //男孩、女孩、两个鬼的位置
int dis(int x1, int y1, int x2, int y2)
{
    return abs(x1 - x2) + abs(y1 - y2);
}
bool check(int x, int y, int t)
{
    if (a[x][y] == 'X' || x &gt; n || x &lt; 1 || y &lt; 1 || y &gt; n)
        return 0;
    if (dis(x, y, z[1].first, z[1].second) &lt;= 2 * t)
        return 0;
    if (dis(x, y, z[2].first, z[2].second) &lt;= 2 * t)
        return 0;
    return 1;
}
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
int bfs()
{
    int gh = 0;
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            if (a[i][j] == 'M')
            {
                boy.first = i;
                boy.second = j;
            }
            if (a[i][j] == 'G')
            {
                girl.first = i;
                girl.second = j;
            }
            if (a[i][j] == 'Z')
            {
                gh++;
                z[gh].first = i;
                z[gh].second = j;
            }
        }
    }
    queue&lt;pii&gt; qb, qg;
    qb.push(boy);
    qg.push(girl);
    int step = 0;
    while (qb.size() || qg.size())
    {
        step++;
        for (int t = 1; t &lt;= 3; t++)
        { //男孩每步相当于bfs三次
            int sz = qb.size();
            for (int j = 1; j &lt;= sz; j++)
            {
                int x = qb.front().first;
                int y = qb.front().second;
                qb.pop();
                if (!check(x, y, step))
                    continue;
                for (int i = 0; i &lt; 4; i++)
                {
                    int nx = x + dx[i];
                    int ny = y + dy[i];
                    if (reach[nx][ny] == 1)
                        continue;
                    if (!check(nx, ny, step))
                        continue;
                    if (reach[nx][ny] == 2)
                        return step;
                    reach[nx][ny] = 1;
                    qb.push(make_pair(nx, ny));
                }
            }
        }
        int sz = qg.size();
        for (int j = 1; j &lt;= sz; j++)
        {
            int x = qg.front().first;
            int y = qg.front().second;
            qg.pop();
            if (!check(x, y, step))
                continue;
            for (int i = 0; i &lt; 4; i++)
            {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (reach[nx][ny] == 2)
                    continue;
                if (!check(nx, ny, step))
                    continue;
                if (reach[nx][ny] == 1)
                    return step;
                reach[nx][ny] = 2;
                qg.push(make_pair(nx, ny));
            }
        }
    }
    return -1;
}
int main()
{
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
                cin &gt;&gt; a[i][j];
        memset(reach, 0, sizeof(reach));
        printf(&quot;%d\n&quot;, bfs());
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI学习笔记】优先队列BFS]]></title>
        <id>https://song-gan.github.io/post/oi-xue-xi-bi-ji-you-xian-dui-lie-bfs/</id>
        <link href="https://song-gan.github.io/post/oi-xue-xi-bi-ji-you-xian-dui-lie-bfs/">
        </link>
        <updated>2022-03-01T05:38:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="优先队列bfs">优先队列BFS</h2>
<ul>
<li>在学了双端队列BFS后，我们知道可以怎样处理对于图上边权是1或0的情况。但是对于更加具有普遍性的情况，也就是每次扩展都有各自不同的“代价”时，我们想要求出从初始状态到每个状态的最小代价，就相当于在一张带权图上求出从起点到每个节点的最短路。</li>
<li>那么，我们有以下两个方案：</li>
</ul>
<h3 id="-方案一">- 方案一：</h3>
<ul>
<li>我们可以采用一般的广搜，用一般的队列来存储。</li>
<li>此时因为我们不能保证每个状态第一次入队时就能得到最小代价，所以我们只能允许一个状态多次更新、多次出进队列，从而更新它的最值，直到队列为空。</li>
<li>那么我们会发现此时的BFS会对搜索树进行很多重复的遍历与更新，直到求出最优解，其实这就是“迭代”的思想。不妨讨论一下最坏情况，该算法的时间复杂度会从一般的BFS的O(N)变为O(N2)。那么其实在最短路问题中，对应的就是SPFA算法。</li>
</ul>
<h3 id="-方案二">- 方案二：</h3>
<ul>
<li>其实除了以上的算法，我们可以通过将一般的队列改为优先队列来进行广搜。</li>
<li>形象的说这里的优先队列就相当于一个二叉堆。我们可以每次从队列中取出当前代价最小的状态进行扩展（此时该状态一定已经是最优解，因为队列中其他状态的当前代价都不小于它，所以以后就不能再更新它了），沿着各条分支把到达的新状态加入到优先队列中，不断搜索，直到队列为空。</li>
<li>那么我们再看优先队列BFS中，每个状态也会被多次更新、多次进出队列，一个状态可能以不同的代价在队列中同时存在。但是，当每个状态第一次从队列中取出时，就得到了从初始状态到该状态的最小代价。从而之后被取出时，我们就可以直接忽略，不进行扩展。</li>
<li>所以，优先队列BFS中每个状态只扩展一次，时间复杂度只多了维护二叉堆的代价。时间复杂度只会从一般BFS的O(N)变为O(N log N)。同样在最短路问题中，对应的是堆优化的Dijkstra算法。</li>
</ul>
<h3 id="-那么我们可以对bfs的形式按照对应在图上边权情况进行分类总结">- 那么我们可以对BFS的形式，按照对应在图上边权情况进行分类总结：</h3>
<ol>
<li>问题只求最少步数，等价于在边权都为1的图上求最短路。<br>
我们使用一般的BFS，时间复杂度为O(N)。<br>
每个状态只访问入队一次，第一次出队时即为该状态的最小代价。</li>
<li>问题每次扩展的代价可能是0或1，等价于在边权只有0或1的图上求最短路。<br>
使用双端队列，时间复杂度为O(N)。<br>
每个状态会被更新入队多次，只扩展一次，第一次出队时就是该状态的最小代价。</li>
<li>问题每次扩展的代价可能是任意数值，等价于一般的最短路问题。</li>
</ol>
<ul>
<li>(1)使用优先队列BFS，时间复杂度O(N log N)。</li>
<li>每个状态被更新入队多次，只扩展一次，第一次出队时即是该状态的最小代价。</li>
<li>(2)使用迭代思想+一般的BFS，时间复杂度O(N2)。</li>
<li>每个状态被更新入队多次，扩展出队多次，最终完成记忆化搜索后，记录数组中保存了最小代价。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI学习笔记】双端队列BFS]]></title>
        <id>https://song-gan.github.io/post/oi-xue-xi-bi-ji-shuang-duan-dui-lie-bfs/</id>
        <link href="https://song-gan.github.io/post/oi-xue-xi-bi-ji-shuang-duan-dui-lie-bfs/">
        </link>
        <updated>2022-02-28T05:32:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="双端队列bfs">双端队列BFS</h2>
<ul>
<li>
<p>在基本的BFS广搜中，每次沿着分支的扩展都记一步，我们通过逐层搜索，解决了求起始状态到每个状态的最少步数问题。这其实等价于在一张边权均为1的图上执行BFS，求出每个点相对于起点的最短距离（层次）。每个状态在第一次被访问并入队时，计算出的步数即为所。</p>
</li>
<li>
<p>但是，如果说图上的边权不全是1呢？就比如当图上的边权是1、0两种状态时，每次拓展都有各自不同的“代价”，那么此时要求出起始状态到每个状态的最小代价就需要用到双端队列来保证队列的两段性和单调性。</p>
</li>
</ul>
<h3 id="deque">deque</h3>
<ul>
<li>
<p>deque容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。但它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。</p>
</li>
<li>
<p>它就像是vector与queue的结合。</p>
</li>
<li>
<p>与vector相比，deque在头部增删元素仅仅需要O(1)的时间；</p>
</li>
<li>
<p>与queue相比，deque像数组一样支持随机访问。</p>
</li>
<li>
<p>让我们来看看deque的函数基本操作：</p>
</li>
</ul>
<h4 id="1构造">1.构造</h4>
<ul>
<li>无参构造：</li>
<li>deque<T> a;　　//&lt;&gt;内自定义数据类型；</li>
<li>带参构造：</li>
<li>deque(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</li>
<li>deque(n,elem); //构造函数将n个elem拷贝给本身。</li>
<li>deque(const deque &amp;deq); //拷贝构造函数。</li>
</ul>
<h4 id="2-头部尾部的添加和删除接下来的dq为变量名">2. 头部&amp;尾部的添加和删除(接下来的’dq’为变量名)</h4>
<ul>
<li>dq.push_back(elem); //在容器尾部添加一个数据</li>
<li>dq.push_front(elem); //在容器头部插入一个数据</li>
<li>dq.pop_back(); //删除容器最后一个数据</li>
<li>dq.pop_front(); //删除容器第一个数据</li>
</ul>
<h4 id="3中间数据存取">3.中间数据存取</h4>
<ul>
<li>dq.at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range。</li>
<li>deque[idx]; //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</li>
<li>dq.front(); //返回第一个数据。</li>
<li>dq.back(); //返回最后一个数据</li>
</ul>
<h4 id="4元素插入">4.元素插入</h4>
<ul>
<li>dq.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li>
<li>dq.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。</li>
<li>dq.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。</li>
</ul>
<h4 id="5数据删除">5.数据删除</h4>
<ul>
<li>dq.clear(); //移除容器的所有数据</li>
<li>dq.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>dq.erase(pos); //删除pos位置的数据，返回下一个数据的位置。</li>
</ul>
<h4 id="6迭代指针">6.迭代指针</h4>
<ul>
<li>dq.begin(); //返回容器中第一个元素的迭代器。</li>
<li>dq.end(); //返回容器中最后一个元素之后的迭代器。</li>
<li>dq.rbegin(); //返回容器中倒数第一个元素的迭代器。</li>
<li>dq.rend(); //返回容器中倒数最后一个元素之后的迭代器。</li>
</ul>
<h4 id="7赋值拷贝">7.赋值&amp;拷贝</h4>
<ul>
<li>dq.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</li>
<li>dq.assign(n,elem); //将n个elem拷贝赋值给本身。</li>
<li>deque&amp; operator=(const deque &amp;deq); //重载等号操作符</li>
<li>dq.swap(deq); // 将vec与本身的元素互换</li>
</ul>
<h4 id="8大小判断非空">8.大小&amp;判断非空</h4>
<ul>
<li>dq.size(); //返回容器中元素的个数</li>
<li>dq.empty(); //判断容器是否为空</li>
<li>dq.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li>dq.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li>
</ul>
<h2 id="例题电路维修"><a href="https://www.acwing.com/problem/content/177/">【例题】电路维修</a></h2>
<h3 id="题解">题解</h3>
<ul>
<li>双端队列主要解决图中边的权值只有0或者1的最短路问题</li>
<li>操作：</li>
<li>每次从队头取出元素，并进行拓展其他元素时
<ol>
<li>若拓展某一元素的边权是0，则将该元素插入到队头</li>
<li>若拓展某一元素的边权是1，则将该元素插入到队尾</li>
</ol>
</li>
<li>回归到题目：<br>
首先明确的一点是，这里是图中的格子和点是不一样的，点是格子上的角角上的点，每个点都有4个方向可以走，分别对应的是左上角，右上角，右下角，左下角。</li>
<li>特别注意：判断“/”C++中要写成“//”！踩过格子到达想去的点时，需要判断是否需要旋转电线，若旋转电线表示从 当前点到想去的点的边权是1，若不旋转电线则边权是0</li>
<li>按左上角，右上角，右下角，左下角遍历的顺序：
<ol>
<li>dx[ ]和dy[ ]表示可以去其他点的方向</li>
<li>id[ ]和iy[ ]表示需要踩某个方向的各种才能去到相应的点</li>
<li>cs[ ]表示当前点走到4个方向的点理想状态下格子形状(边权是0的状态)</li>
</ol>
</li>
<li>时间复杂度 O(nm)</li>
<li>如下面的程序就用“BFS+双端队列”就解决了该问题：</li>
<li>（蒟蒻的双端队列用STL的deque实现，要程序跑得更快，可以手写双端队列）：</li>
</ul>
<pre><code class="language-cpp">//DC Songxingan
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;
const int maxn = 510;
int t, n, m, ans[maxn][maxn];
char map[maxn][maxn];
struct Node
{
    int x, y;
};  //坐标
deque&lt;Node&gt; dq;  //双端队列

void BFS()  //广搜
{
    while (!dq.empty())
    {
        Node lin, now;
        lin = dq.front();
        dq.pop_front();
//-----从4个方向搜索可到格点-----
        if (lin.x &gt; 1 &amp;&amp; lin.y &gt; 1)  //边界判断
        {
            now.x = lin.x - 1;
            now.y = lin.y - 1;  //更新搜索的点坐标
            int flag = 0;
            if (map[now.x][now.y] != '\\')  //若要旋转则边权为1
            {
                flag = 1;
            }

            if (ans[now.x][now.y] &gt; ans[lin.x][lin.y] + flag)
//判断当前搜索的点是否已经被搜过或是否是最有解
            {
                ans[now.x][now.y] = ans[lin.x][lin.y] + flag;
//边权值为1 放在队尾，为0放在队首
                if (flag)
                    dq.push_back(now);
                else
                    dq.push_front(now);
            }
        }
//接下剩下3个方向搜索同理
        if (lin.x &gt; 1 &amp;&amp; lin.y &lt;= m)
        {
            now.x = lin.x - 1;
            now.y = lin.y + 1;
            int flag = 0;
            if (map[now.x][lin.y] != '/')
            {
                flag = 1;
            }

            if (ans[now.x][now.y] &gt; ans[lin.x][lin.y] + flag)
            {
                ans[now.x][now.y] = ans[lin.x][lin.y] + flag;
                if (flag)
                    dq.push_back(now);
                else
                    dq.push_front(now);
            }
        }
        if (lin.x &lt;= n &amp;&amp; lin.y &lt;= m)
        {
            now.x = lin.x + 1;
            now.y = lin.y + 1;
            int flag = 0;
            if (map[lin.x][lin.y] != '\\')
            {
                flag = 1;
            }

            if (ans[now.x][now.y] &gt; ans[lin.x][lin.y] + flag)
            {
                ans[now.x][now.y] = ans[lin.x][lin.y] + flag;
                if (flag)
                    dq.push_back(now);
                else
                    dq.push_front(now);
            }
        }
        if (lin.x &lt;= n &amp;&amp; lin.y &gt; 1)
        {
            now.x = lin.x + 1;
            now.y = lin.y - 1;
            int flag = 0;
            if (map[lin.x][now.y] != '/')
            {
                flag = 1;
            }

            if (ans[now.x][now.y] &gt; ans[lin.x][lin.y] + flag)
            {
                ans[now.x][now.y] = ans[lin.x][lin.y] + flag;
                if (flag)
                    dq.push_back(now);
                else
                    dq.push_front(now);
            }
        }
    }
}
int main()
{
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; ++i)
        {
            scanf(&quot;%s&quot;, map[i] + 1);
        }
        if ((n + m) % 2 == 1)  //可行性剪枝：如果行数加列数不是偶数则无解
        {
            printf(&quot;NO SOLUTION\n&quot;);
            continue;
        }
//------初始化------
        Node fir;
        fir.x = 1;
        fir.y = 1;
        dq.clear();
        dq.push_front(fir);
        memset(ans, 0x7f, sizeof(ans));
        ans[1][1] = 0;
        BFS();
        printf(&quot;%d\n&quot;, ans[n + 1][m + 1]);  //注意输出的是格点
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI学习笔记】状态图搜索]]></title>
        <id>https://song-gan.github.io/post/oi-xue-xi-bi-ji-zhuang-tai-tu-sou-suo/</id>
        <link href="https://song-gan.github.io/post/oi-xue-xi-bi-ji-zhuang-tai-tu-sou-suo/">
        </link>
        <updated>2022-02-28T05:14:09.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>BFS搜索处理的对象有很多种（根据题目而定），除了数它还可能是一个状态，对于状态空间的就叫做状态图搜索。</p>
</li>
<li>
<p>状态空间搜索一般是找到一条从初始状态到最终状态的一条最优路径，可以归结为隐式图的搜索问题，图中的节点就是在搜索过程中的状态。</p>
</li>
</ul>
<h2 id="八数码问题">八数码问题</h2>
<ul>
<li>
<p>在一个3*3的方棋盘上放置着1,2,3,4,5,6,7,8八个数码,每个数码占一格,且有一个空格（输入用‘0’表示）。这些数码可以在棋盘上移动，其移动规则是：与空格相邻的数码方格可以移入空格。现在的问题是：对于指定的初始棋局和目标棋局（如图5.1.1-1所示），任务1：问最小移动步数，若无法到达输出-1；任务2：给出数码的移动序列。该问题称八数码难题或者重排九宫问题。</p>
</li>
<li>
<p>输入样例：<br>
1 2 3 0 8 4 7 6 5<br>
1 0 3 8 2 4 7 6 5</p>
</li>
<li>
<p>输出样例：<br>
2</p>
</li>
<li>
<p>不难把八数码问题归结为图上的最短路问题，图的“结点”就是9个格子中的滑块编号（从上到下、从左到右把它们放到一个包含9个元素的数组中）。无权图上的最短路问题可以用BFS求解。从初始状态出发，每次搜索转移状态，一层层搜索，渐渐接近目标状态，那么到达目标状态时经过的步数就是最短路径。</p>
</li>
<li>
<p>这道题目主要的难点就是判断重复，显然直接判断矩阵最坏情况是比较9!*9!（9!=362880）次，如此暴力判断重复不可行，一定会超时，故使用哈希方法，字符串存储数码，然后使用康托展开来判断重复。</p>
</li>
</ul>
<h3 id="康拓展开">*康拓展开</h3>
<ul>
<li>康托展开是一个全排列到一个自然数的双射，常用于构建Hash表时的空间压缩。康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，设有n个数{1,2,3,...,n}，可以有组成不同(n!种)的排列组合，康托展开表示的就是在n个不同元素的全排列中, 比当前排列组合小的个数，那么也可以表示当前排列组合在n个不同元素的全排列中的名次（当前的名次 = 比当前排列组合小的个数 + 1）。因此也是可逆的，先给出康托展开的公式：</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>×</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>!</mo><mo>+</mo><mi>a</mi><mo>[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>×</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>!</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>!</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>a</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>∗</mo><mn>0</mn><mo>!</mo></mrow><annotation encoding="application/x-tex">x = a[n] \times (n - 1)! + a[n - 1] \times (n - 2)! + ...+ a[i] \times (i- 1)! + ... +  a[1] * 0!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mclose">!</span></span></span></span></p>
<ul>
<li>
<p>其中, a[i]为整数，（注意：i从右往左数）并且0 &lt;= a[i] &lt;= i, 0 &lt;= i &lt; n, 表示当前未出现的的元素中排第几个，这就是康托展开。</p>
</li>
<li>
<p>假设有一个排列{1,2,3}，则其排列组合及其相应的康托展开值如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">排列组合</th>
<th style="text-align:center">名次</th>
<th style="text-align:center">康拓展开</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">123</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>×</mo><mn>2</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>1</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo>!</mo></mrow><annotation encoding="application/x-tex">0 \times 2! + 0 \times 1! + 0 \times 0!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mclose">!</span></span></span></span></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">132</td>
<td style="text-align:center">2</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>×</mo><mn>2</mn><mo>!</mo><mo>+</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo>!</mo></mrow><annotation encoding="application/x-tex">0 \times 2! + 1 \times 1! + 0 \times 0!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mclose">!</span></span></span></span></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">213</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>2</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>1</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo>!</mo></mrow><annotation encoding="application/x-tex">1 \times 2! + 0 \times 1! + 0 \times 0!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mclose">!</span></span></span></span></td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">231</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>2</mn><mo>!</mo><mo>+</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo>!</mo></mrow><annotation encoding="application/x-tex">1 \times 2! + 1 \times 1! + 0 \times 0!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mclose">!</span></span></span></span></td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">312</td>
<td style="text-align:center">5</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>1</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo>!</mo></mrow><annotation encoding="application/x-tex">2 \times 2! + 0 \times 1! + 0 \times 0!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mclose">!</span></span></span></span></td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">321</td>
<td style="text-align:center">6</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn><mo>!</mo><mo>+</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo>!</mo></mrow><annotation encoding="application/x-tex">2 \times 2! + 1 \times 1! + 0 \times 0!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mclose">!</span></span></span></span></td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>举个例子，在(1,2,3,4,5)5个数的排列组合中，计算 34152的康托展开值。</p>
</li>
<li>
<p>首位是3，则小于3的数有两个，为1和2，a[5] = 2，则首位小于3的所有排列组合为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>5</mn><mo>]</mo><mo>×</mo><mo>(</mo><mn>5</mn><mo>−</mo><mn>1</mn><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">a[5] \times (5-1)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></p>
</li>
<li>
<p>第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此 a[4] = 2</p>
</li>
<li>
<p>第三位是1，则在其之后小于1的数有0个，所以 a[3] = 0</p>
</li>
<li>
<p>第四位是5，则在其之后小于5的数有1个，为2，所以 a[2] = 1</p>
</li>
<li>
<p>最后一位就不用计算啦，因为在它之后已经没有数了，所以 a[1] 固定为0</p>
</li>
<li>
<p>根据公式：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>2</mn><mo>×</mo><mn>4</mn><mo>!</mo><mo>+</mo><mn>2</mn><mo>×</mo><mn>3</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>2</mn><mo>!</mo><mo>+</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo>!</mo><mo>=</mo><mn>2</mn><mo>×</mo><mn>24</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>6</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>61</mn></mrow><annotation encoding="application/x-tex">x = 2 \times 4! + 2 \times 3! + 0 \times 2! + 1 \times 1! + 0 \times 0! = 2 \times 24 + 2 \times 6 + 1 = 61</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">1</span></span></span></span></p>
</li>
<li>
<p>所以比 34152 小的组合有61个，即34152是排第62。</p>
</li>
</ul>
<h3 id="逆康托展开">*逆康托展开</h3>
<ul>
<li>
<p>一开始已经提过了，康托展开是一个全排列到一个自然数的双射，因此是可逆的。即对于上述例子，在(1,2,3,4,5)给出61可以算出起排列组合为34152。由上述的计算过程可以容易的逆推回来，具体过程如下：</p>
</li>
<li>
<p>用 61 / 4! = 2余13，说明 a[5] = 2 ,说明比首位小的数有2个，所以首位为3。</p>
</li>
<li>
<p>用 13 / 3! = 2余1，说明 a[4] = 2 ，说明在第二位之后小于第二位的数有2个，所以第二位为4。</p>
</li>
<li>
<p>用 1 / 2! = 0余1，说明 a[3] = 0 ，说明在第三位之后没有小于第三位的数，所以第三位为1。</p>
</li>
<li>
<p>用 1 / 1! = 1余0，说明 a[2] = 1 ，说明在第二位之后小于第四位的数有1个，所以第四位为5。</p>
</li>
<li>
<p>最后一位自然就是剩下的数2啦。</p>
</li>
<li>
<p>通过以上分析，所求排列组合为 34152。</p>
</li>
</ul>
<h4 id="-如下面的程序就用bfscantor就解决了八数码问题">- 如下面的程序就用“BFS+Cantor”就解决了八数码问题：</h4>
<ul>
<li>（BFS中用STL的queue实现）</li>
</ul>
<pre><code class="language-cpp">
//DC Songxingan
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;
const int LEN = 362888; //状态共9!=362880种
struct node
{
    int state[9]; //记录一个八数码的排列，即一个状态
    int dis;      //记录到起点的距离
};

int dir[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
//左、上、右、下顺时针方向。左上角坐标是(0,0)
int visited[LEN] = {0};
//与每个状态对应的记录，Cantor函数对它置数，并判重
int start[9]; //开始状态
int goal[9];  //目标状态
long int factory[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
//Cantor用到的常数
bool Cantor(int str[], int n)
{ //用康托展开判重
    long result = 0;
    for (int i = 0; i &lt; n; i++)
    {
        int counted = 0;
        for (int j = i + 1; j &lt; n; j++)
        {
            if (str[i] &gt; str[j]) //当前未出现的元素中是排在第几个
                ++counted;
        }
        result += counted * factory[n - i - 1];
    }
    if (!visited[result])
    { //没有被访问过
        visited[result] = 1;
        return 1;
    }
    else
        return 0;
}
int bfs()
{
    node head;
    memcpy(head.state, start, sizeof(head.state)); //复制起点的状态
    head.dis = 0;
    queue&lt;node&gt; q; //队列中放状态
    Cantor(head.state, 9);
    //用康托展开判重，目的是对起点的visited[]赋初值
    q.push(head); //第一个进队列的是起点状态

    while (!q.empty())
    { //处理队列
        head = q.front();
        q.pop();
        //可在此处打印head.state，看弹出队列的情况
        int z;
        for (z = 0; z &lt; 9; z++)     //找这个状态中元素0的位置
            if (head.state[z] == 0) //找到了
                break;
        //转化为二维，左上角是原点(0, 0)。
        int x = z % 3; //横坐标
        int y = z / 3; //纵坐标
        for (int i = 0; i &lt; 4; i++)
        {
            //上、下、左、右最多可能有4个新状态
            int newx = x + dir[i][0]; //元素0转移后的新坐标
            int newy = y + dir[i][1];
            int nz = newx + 3 * newy; //转化为一维
            if (newx &gt;= 0 &amp;&amp; newx &lt; 3 &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; 3)
            { //未越界
                node newnode;
                memcpy(&amp;newnode, &amp;head, sizeof(struct node));
                //复制这新的状态
                swap(newnode.state[z], newnode.state[nz]);
                //把0移动到新的位置
                newnode.dis++;
                if (memcmp(newnode.state, goal, sizeof(goal)) == 0)
                    //与目标状态对比
                    return newnode.dis;       //到达目标状态，返回距离，结束
                if (Cantor(newnode.state, 9)) //用康托展开判重
                    q.push(newnode);          //把新的状态放进队列
            }
        }
    }
    return -1; //没找到
}
int main()
{
    for (int i = 0; i &lt; 9; i++)
        cin &gt;&gt; start[i]; //初始状态
    for (int i = 0; i &lt; 9; i++)
        cin &gt;&gt; goal[i]; //目标状态
    int num = bfs();
    if (num != -1)
        cout &lt;&lt; num &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl;
    return 0;
}

</code></pre>
<ul>
<li>注意到这一道题，其实有很多方法解决，例如：双向广搜、A*、IDA<em>等等。八数码问题只有9！种状态，对于更大的问题，例如4</em>4的15数码问题，就有16!≈2×1013种状态，就需要更好的方法，具体可见：https://www.cnblogs.com/zufezzt/p/5659276.html（八境界）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI学习笔记】搜索剪枝]]></title>
        <id>https://song-gan.github.io/post/oi-xue-xi-bi-ji-sou-suo-jian-zhi/</id>
        <link href="https://song-gan.github.io/post/oi-xue-xi-bi-ji-sou-suo-jian-zhi/">
        </link>
        <updated>2022-02-27T05:34:49.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>搜索算法的时间复杂度大多是指数级的，难以满足对程序运行时间的限制要求，为使降低时间复杂度，对深度优先搜索可以进行一种优化的基本方法——剪枝。</p>
</li>
<li>
<p>剪枝，就是减小搜索树的规模、尽早排除搜索树中一些不必要的分支的一种手段技巧。搜索的进程可以看做是从树根出发，遍历一颗倒置树（搜索树）的过程，所谓剪枝，就是通过某些判断，避免一些不必要的遍历过程，形象的说，就好像是减去搜索树中的某些枝条，也顾名思义叫做“剪枝”。</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://www.imageoss.com/images/2022/02/27/OI03305db50931c11e.png" alt="搜索剪枝" loading="lazy"></figure>
<ul>
<li>
<p>显而易见，应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条舍弃哪些枝条保留，设计出好的剪枝判断方法，可以使得程序运行时间大大缩短，否则会适得其反。</p>
</li>
<li>
<p>剪枝的原则：正确、准确、高效</p>
</li>
</ul>
<h2 id="剪枝优化技巧">剪枝优化技巧</h2>
<ol>
<li>
<p>优化搜索顺序<br>
在不同的搜索问题中，搜索树的各个层次、各个分支之间的顺序不是固定的，不同的搜索顺序会产生不同的搜索树形态，其规模大小也相差甚远。</p>
</li>
<li>
<p>排除等效冗余<br>
在搜索过程中，若能判断从搜索树当前节点上沿某几条不同分支到达的子树是相同的，那么只需对其中一条分支执行搜索。</p>
</li>
<li>
<p>可行性剪枝<br>
可行性剪枝也叫上下界剪枝，其是指在搜索过程中，及时对当前状态进行检查，若发现分支已无法到达递归边界，就执行回溯。这就好比我们在道路上行走时，远远看到前方是一条死胡同，就应该立即折返，重新选择道路，而不是走到头再折返。</p>
</li>
<li>
<p>最优性剪枝<br>
在最优化问题的搜索过程中，若当前花费的代价已超过当前搜索到的最优解，那么无论采取多么优秀的策略到达递归边界，都不可能更新答案，此时可以停止对当前分支的搜索进行回溯。</p>
</li>
<li>
<p>记忆化<br>
记忆化正如字面意思，记录每个状态的搜索结果，在重复遍历一个状态时直接检索并返回。这就好比我们对图进行深度优先遍历时，标记一个节点时是否已经被访问过，可以直接调用记录的数据，就可以节省再次重复计算的时间。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI学习笔记】二分算法]]></title>
        <id>https://song-gan.github.io/post/oi-xue-xi-bi-ji-er-fen-suan-fa/</id>
        <link href="https://song-gan.github.io/post/oi-xue-xi-bi-ji-er-fen-suan-fa/">
        </link>
        <updated>2022-02-26T12:17:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="二分算法">二分算法</h2>
<ul>
<li>
<p>二分的本质并不是单调性，如果有单调性一定可以二分，可以二分但不一定有单调性。</p>
</li>
<li>
<p>二分的本质：边界。</p>
</li>
</ul>
<h2 id="整数二分">整数二分</h2>
<h3 id="整数二分算法模板">整数二分算法模板：</h3>
<ul>
<li>
<p>二分模板一共有两个，分别适用于不同情况。</p>
</li>
<li>
<p>算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。</p>
</li>
</ul>
<h4 id="版本1">版本1</h4>
<ul>
<li>当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;计算mid时不需要加1。</li>
</ul>
<pre><code class="language-cpp">int bsearch_1(int l, int r)
{
	while (l &lt; r)
	{
		int mid = l + r &gt;&gt; 1;
		if (check(mid))
			r = mid;
		else
			l = mid + 1;
	}
	return l;
}
</code></pre>
<h4 id="版本2">版本2</h4>
<ul>
<li>当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。</li>
</ul>
<pre><code class="language-cpp">int bsearch_2(int l, int r)
{
	while (l &lt; r)
	{
		int mid = l + r + 1 &gt;&gt; 1;
		if (check(mid))
			l = mid;
		else
			r = mid - 1;
	}
	return l;
}
</code></pre>
<h3 id="整数二分算法模板-模板题-acwing-789-数的范围">整数二分算法模板 —— 模板题  <a href="https://www.acwing.com/problem/content/791/">AcWing 789. 数的范围</a></h3>
<pre><code class="language-cpp">bool check(int x)
{ 
	/* ... */
} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
	while (l &lt; r)
	{
		int mid = l + r &gt;&gt; 1;
		if (check(mid))
			r = mid; // check()判断mid是否满足性质
		else
			l = mid + 1;
	}
	return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
	while (l &lt; r)
	{
		int mid = l + r + 1 &gt;&gt; 1;
		if (check(mid))
			l = mid;
		else
			r = mid - 1;
	}
	return l;
}
</code></pre>
]]></content>
    </entry>
</feed>